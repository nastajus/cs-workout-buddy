syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

service Everything {

	rpc GetWorkoutsAll (.google.protobuf.Empty) returns ();	//i suppose user is already known on server...hmm... //todo: an implementation detail to choose

	rpc GetWorkoutsOf (Exercise.Type) returns ()

	rpc StartWorkout (); //??? 

	//The repeated field approach is akin to batching, and requires all of the messages to be prepared by the server before any are sent, and the entire set of messages to be received by the client before doing any processing, increasing latency

	//one was stream reply

	// one was repeated reply

	rpc GetHistoryRecent() returns ( );	//perhaps have default upToTime?...?

	//todo: does it make sense to use the same return type as was used to call? I *think* so, but hold reserved doubts. TBD via implementing safely/sanely.
	rpc GetHistoryAll(Exercise) returns (stream Exercise); //let this be streaming, let it keep causing scrolling		

}

// ~~~ a Workout session has multiple Exercises done within it. ~~ i mean... from a data MODELLING perspective... but in terms messages...nah?
// can be used to track starting time when opening app at gym arrival for example
// used to simply register it is simply active, so that a buddy can join in while one perons's is active.
message Workout {

	//required int32 userId

	User who = 1;

	WorkoutState state = 2;

}

enum WorkoutState {

	START = 0;
	STOP = 1;
	RESTART = 2;

}

// an Exercise instance, composed of multiple sets
message Exercise {

	string name = 1;
	
	ExerciseType type = 2;

	repeated Set set = 3;

	message Type {
		string name = 1;	//todo: resolve my displeasure at having to type in C# redundantly name & type: `new Exercise.Type{ Name = "Bicep Curl"};`
	}

	string note = 10;

}

//todo: decide a guid stategy. roughly, i want individual reps to be reconstructable in order without sets. ditto up a level of abstraction... tbd how.
//todo: decide how to handle either A) aborted reps after 0 or 1, and B) how to handle simplist scenarios that don't require this much granular detail
message Set {

	repeated Rep rep = 1;

}

message Rep {

	int32 amount = 1;

	// named as used in the convential sense, but his really means mass not weight technically.
	int32 weight = 2;

	UnitsMassType units = 3;
	

}

enum ExerciseType {

	STRENGTH = 0;
	CARDIO = 1;
	STRECTH = 2;

}

enum UnitsMassType {

	option allow_alias = true;
	LBS = 0;
	POUNDS = 0;
	KG = 1;
	KILOGRAMS = 1;

} 


// for authentication... todo: investigate possibly replace grpc message User with superior authentication later? 
// for buddy matching...
message User  {

	string username = 1;

}